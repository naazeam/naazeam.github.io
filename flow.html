<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Map Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #E2E8F0;
            overscroll-behavior: none;
        }
        [contenteditable="true"] { outline: 2px solid #38B2AC; border-radius: 4px; padding: 2px; }
        .node {
            position: absolute;
            z-index: 10;
            cursor: grab;
            touch-action: none;
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .node.selected {
            box-shadow: 0 0 0 3px #4FD1C5;
        }
        .node:hover { transform: translateY(-2px); }
        .node.dragging { cursor: grabbing; z-index: 20; transform: scale(1.05); }
        .node-svg { width: 100%; height: 100%; }
        .node-svg-shape { stroke: #4A5568; stroke-width: 2px; }
        .node-name { position: absolute; width: 85%; text-align: center; color: white; font-weight: 500; pointer-events: none; }
        .connector {
            position: absolute; width: 16px; height: 16px;
            background-color: #4A5568; border: 2px solid #2D3748;
            border-radius: 50%; cursor: crosshair; z-index: 15;
            transition: background-color 0.2s ease-in-out;
        }
        .connector:hover { background-color: #4FD1C5; }
        .connector.top { top: -8px; left: 50%; transform: translateX(-50%); }
        .connector.bottom { bottom: -8px; left: 50%; transform: translateX(-50%); }
        #main-canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #color-palette {
            position: fixed; z-index: 40; background-color: #2D3748;
            border: 1px solid #4A5568; border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            padding: 8px; display: flex; gap: 8px;
        }
        #sidebar { transition: transform 0.3s ease-in-out; }
        #sidebar.collapsed { transform: translateX(-100%); }
        .library-item { cursor: grab; }
        .icon-btn { cursor: pointer; color: #A0AEC0; transition: color 0.2s ease-in-out; }
        .icon-btn:hover { color: #E2E8F0; }
    </style>
</head>
<body class="overflow-hidden">

    <!-- Sidebar -->
    <div id="sidebar" class="fixed top-0 left-0 h-full w-64 bg-gray-800/70 backdrop-blur-md z-40 p-4 shadow-2xl">
        <h2 class="text-lg font-bold mb-4">Element Library</h2>
        <div class="space-y-3">
            <div class="library-item bg-gray-700 p-3 rounded-lg flex items-center gap-3" draggable="true" data-shape="rectangle" data-name="Page">
                <svg viewBox="0 0 160 96" class="w-10 h-8"><rect x="1" y="1" width="158" height="94" rx="8" fill="#4A5568" stroke="#A0AEC0" stroke-width="2"></rect></svg>
                <span>Rectangle</span>
            </div>
             <div class="library-item bg-gray-700 p-3 rounded-lg flex items-center gap-3" draggable="true" data-shape="oval" data-name="Start/End">
                <svg viewBox="0 0 160 96" class="w-10 h-8"><ellipse cx="80" cy="48" rx="79" ry="47" fill="#4A5568" stroke="#A0AEC0" stroke-width="2"></ellipse></svg>
                <span>Oval</span>
            </div>
             <div class="library-item bg-gray-700 p-3 rounded-lg flex items-center gap-3" draggable="true" data-shape="diamond" data-name="Decision">
                <svg viewBox="0 0 160 96" class="w-10 h-8"><path d="M80 1 L159 48 L80 95 L1 48 Z" fill="#4A5568" stroke="#A0AEC0" stroke-width="2"></path></svg>
                <span>Diamond</span>
            </div>
        </div>
    </div>
    
    <!-- Main Content -->
    <div id="main-content" class="relative w-full h-screen transition-all duration-300 ease-in-out">
        <!-- Toolbar -->
        <div class="absolute top-0 left-0 right-0 p-4 flex justify-between items-center z-30">
             <div class="flex items-center gap-4">
                 <button id="sidebar-toggle-btn" class="p-2 rounded-md hover:bg-gray-700 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
                <div>
                    <div class="flex items-center gap-2">
                        <h1 id="main-title" class="text-xl font-bold">Website Map</h1>
                        <svg id="edit-title-btn" class="w-4 h-4 icon-btn" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 1 1 3.536 3.536L6.5 21.036H3v-3.536L16.532 3.464z"></path></svg>
                    </div>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <button id="save-btn" class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-medium py-2 px-4 rounded-lg shadow-md transition-colors">Save as PNG</button>
                <button id="add-node-btn" class="bg-teal-700 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">Add Page</button>
            </div>
        </div>

        <!-- Node and Canvas Container -->
        <div id="diagram-container" class="w-full h-full" tabindex="0">
            <canvas id="main-canvas"></canvas>
            <div id="nodes-container"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const diagramContainer = document.getElementById('diagram-container');
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const nodesContainer = document.getElementById('nodes-container');
        const addNodeBtn = document.getElementById('add-node-btn');
        const saveBtn = document.getElementById('save-btn');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('main-content');
        const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
        const mainTitle = document.getElementById('main-title');
        const editTitleBtn = document.getElementById('edit-title-btn');

        // --- State Management ---
        let nodes = [];
        let connections = [];
        let history = [];
        let historyIndex = -1;
        let nextNodeId = 0;
        let isDraggingNode = false, isDrawingConnection = false, isDragCopying = false;
        let draggedNodeId = null, selectedNodeId = null, connectionStartNode = null;
        let clipboard = null;
        let mouse = { x: 0, y: 0 }, offset = { x: 0, y: 0 };
        let isSidebarOpen = true;
        const VIBRANT_COLORS = ['#EF4444', '#F97316', '#EAB308', '#22C55E', '#3B82F6', '#8B5CF6', '#EC4899'];

        // --- History (Undo/Redo) ---
        const saveState = () => {
            const state = {
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections)),
                nextNodeId: nextNodeId
            };
            history = history.slice(0, historyIndex + 1);
            history.push(state);
            historyIndex++;
        };

        const loadState = (state) => {
            nodes = JSON.parse(JSON.stringify(state.nodes));
            connections = JSON.parse(JSON.stringify(state.connections));
            nextNodeId = state.nextNodeId;
            renderNodes();
        };

        const undo = () => { if (historyIndex > 0) { historyIndex--; loadState(history[historyIndex]); }};
        const redo = () => { if (historyIndex < history.length - 1) { historyIndex++; loadState(history[historyIndex]); }};

        // --- Rendering ---
        const resizeCanvas = () => { canvas.width = diagramContainer.clientWidth; canvas.height = diagramContainer.clientHeight; redrawAll(); };
        const redrawAll = () => { requestAnimationFrame(() => { clearCanvas(); drawConnections(); if (isDrawingConnection) drawTempConnection(); }); };
        const clearCanvas = () => ctx.clearRect(0, 0, canvas.width, canvas.height);

        const drawArrowhead = (from, to, targetCtx = ctx) => {
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const headlen = 15;
            targetCtx.beginPath();
            targetCtx.moveTo(to.x, to.y);
            targetCtx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
            targetCtx.moveTo(to.x, to.y);
            targetCtx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
            targetCtx.stroke();
        };

        const drawConnections = (targetCtx = ctx) => {
            targetCtx.strokeStyle = 'rgba(113, 128, 150, 0.6)';
            targetCtx.lineWidth = 2.5;
            connections.forEach(conn => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                if (!fromNode || !toNode) return;

                const fromPos = { x: fromNode.x + fromNode.width / 2, y: fromNode.y + fromNode.height };
                const toPos = { x: toNode.x + toNode.width / 2, y: toNode.y };
                
                targetCtx.beginPath();
                targetCtx.moveTo(fromPos.x, fromPos.y);
                const cp1 = { x: fromPos.x, y: fromPos.y + 60 };
                const cp2 = { x: toPos.x, y: toPos.y - 60 };
                targetCtx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, toPos.x, toPos.y);
                targetCtx.stroke();
                drawArrowhead(cp2, toPos, targetCtx);
            });
        };
        
        const drawTempConnection = () => {
            const startPos = { x: connectionStartNode.x + connectionStartNode.width / 2, y: connectionStartNode.y + connectionStartNode.height };
            ctx.strokeStyle = '#4FD1C5'; ctx.lineWidth = 3; ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(startPos.x, startPos.y);
            ctx.bezierCurveTo(startPos.x, startPos.y + 60, mouse.x, mouse.y - 60, mouse.x, mouse.y);
            ctx.stroke();
            ctx.setLineDash([]);
        };

        const renderNodes = () => {
            nodesContainer.innerHTML = '';
            nodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.id = `node-${node.id}`;
                nodeEl.className = `node ${node.id === selectedNodeId ? 'selected' : ''}`;
                nodeEl.style.cssText = `left:${node.x}px; top:${node.y}px; width:${node.width}px; height:${node.height}px;`;

                let shapeSvg = '';
                if (node.shape === 'rectangle') shapeSvg = `<rect x="1" y="1" width="${node.width-2}" height="${node.height-2}" rx="8" fill="${node.color}"></rect>`;
                else if (node.shape === 'oval') shapeSvg = `<ellipse cx="${node.width/2}" cy="${node.height/2}" rx="${node.width/2-1}" ry="${node.height/2-1}" fill="${node.color}"></ellipse>`;
                else if (node.shape === 'diamond') shapeSvg = `<path d="M${node.width/2} 1 L${node.width-1} ${node.height/2} L${node.width/2} ${node.height-1} L1 ${node.height/2} Z" fill="${node.color}"></path>`;

                nodeEl.innerHTML = `
                    <svg class="node-svg" viewBox="0 0 ${node.width} ${node.height}">${shapeSvg}</svg>
                    <div class="node-name">${node.name}</div>
                    <div class="absolute top-1 right-1 flex gap-1 bg-black/20 rounded-full p-0.5">
                        <div class="edit-icon p-1 rounded-full hover:bg-black/30"><svg class="w-3 h-3 icon-btn" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 1 1 3.536 3.536L6.5 21.036H3v-3.536L16.532 3.464z"></path></svg></div>
                        <div class="color-icon p-1 rounded-full hover:bg-black/30"><svg class="w-3 h-3 icon-btn" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path></svg></div>
                        <div class="delete-icon p-1 rounded-full hover:bg-black/30"><svg class="w-3 h-3 icon-btn" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12"></path></svg></div>
                    </div>
                    <div class="connector top"></div><div class="connector bottom"></div>`;
                
                nodesContainer.appendChild(nodeEl);

                // Event Listeners
                nodeEl.addEventListener('mousedown', (e) => handleNodeMouseDown(e, node.id));
                nodeEl.querySelector('.edit-icon').addEventListener('click', (e) => { e.stopPropagation(); makeEditable(nodeEl.querySelector('.node-name'), node.id); });
                nodeEl.querySelector('.color-icon').addEventListener('click', (e) => { e.stopPropagation(); showColorPalette(node.id, nodeEl); });
                nodeEl.querySelector('.delete-icon').addEventListener('click', (e) => { e.stopPropagation(); deleteNode(node.id); });
            });
            redrawAll();
        };
        
        // --- Core Logic ---
        const createNode = (x, y, name, shape = 'rectangle', color) => {
            const newNode = {
                id: nextNodeId++, name: name || `Page ${nextNodeId}`, shape, x, y,
                width: 160, height: 96,
                color: color || VIBRANT_COLORS[Math.floor(Math.random() * VIBRANT_COLORS.length)]
            };
            nodes.push(newNode);
            setSelectedNode(newNode.id);
            saveState();
            renderNodes();
            return newNode;
        };

        const deleteNode = (nodeId) => {
            nodes = nodes.filter(n => n.id !== nodeId);
            connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
            saveState();
            renderNodes();
        };

        const setSelectedNode = (nodeId) => {
            selectedNodeId = nodeId;
            renderNodes();
        };

        const showColorPalette = (nodeId, nodeEl) => {
            document.getElementById('color-palette')?.remove();
            const palette = document.createElement('div');
            palette.id = 'color-palette';
            VIBRANT_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:border-white transition-all';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const node = nodes.find(n => n.id === nodeId);
                    node.color = color;
                    palette.remove();
                    saveState();
                    renderNodes();
                });
                palette.appendChild(swatch);
            });
            document.body.appendChild(palette);
            const rect = nodeEl.getBoundingClientRect();
            palette.style.left = `${rect.left}px`;
            palette.style.top = `${rect.bottom + 8}px`;
            setTimeout(() => document.addEventListener('click', () => palette.remove(), { once: true }), 0);
        };

        const makeEditable = (element, nodeId) => {
            element.contentEditable = true;
            element.focus(); document.execCommand('selectAll', false, null);
            const onBlur = () => {
                element.contentEditable = false;
                if (nodeId !== undefined) {
                    const node = nodes.find(n => n.id === nodeId);
                    if (node && node.name !== element.textContent) {
                        node.name = element.textContent;
                        saveState();
                    }
                }
            };
            element.addEventListener('blur', onBlur, { once: true });
            element.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); element.blur(); } });
        };
        
        const handleSave = () => {
            if (nodes.length === 0) return;

            const padding = 100;
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;

            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
            });

            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            
            const scale = 2; // For higher resolution
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = (contentWidth + padding * 2) * scale;
            offscreenCanvas.height = (contentHeight + padding * 2) * scale;
            const offCtx = offscreenCanvas.getContext('2d');
            offCtx.scale(scale, scale);

            // Draw background
            offCtx.fillStyle = '#1a202c';
            offCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            
            offCtx.translate(-minX + padding, -minY + padding);

            // Draw connections
            drawConnections(offCtx);

            // Draw nodes
            nodes.forEach(node => {
                offCtx.fillStyle = node.color;
                offCtx.beginPath();
                if (node.shape === 'rectangle') {
                    offCtx.roundRect(node.x, node.y, node.width, node.height, 8);
                } else if (node.shape === 'oval') {
                    offCtx.ellipse(node.x + node.width / 2, node.y + node.height / 2, node.width / 2, node.height / 2, 0, 0, 2 * Math.PI);
                } else if (node.shape === 'diamond') {
                    offCtx.moveTo(node.x + node.width / 2, node.y);
                    offCtx.lineTo(node.x + node.width, node.y + node.height / 2);
                    offCtx.lineTo(node.x + node.width / 2, node.y + node.height);
                    offCtx.lineTo(node.x, node.y + node.height / 2);
                    offCtx.closePath();
                }
                offCtx.fill();

                // Draw text
                offCtx.fillStyle = '#FFFFFF';
                offCtx.font = '500 16px Inter';
                offCtx.textAlign = 'center';
                offCtx.textBaseline = 'middle';
                offCtx.fillText(node.name, node.x + node.width / 2, node.y + node.height / 2);
            });

            // Trigger download
            const link = document.createElement('a');
            link.download = `${mainTitle.textContent.trim().replace(/ /g, '_')}.png`;
            link.href = offscreenCanvas.toDataURL('image/png');
            link.click();
        };

        // --- Event Handlers ---
        const handleKeyDown = (e) => {
            if (e.target.isContentEditable) return;
            const isMod = e.ctrlKey || e.metaKey;
            if (isMod && e.key.toLowerCase() === 'c') {
                if (selectedNodeId !== null) clipboard = JSON.parse(JSON.stringify(nodes.find(n => n.id === selectedNodeId)));
            } else if (isMod && e.key.toLowerCase() === 'v') {
                if (clipboard) {
                    createNode(clipboard.x + 20, clipboard.y + 20, clipboard.name, clipboard.shape, clipboard.color);
                }
            } else if (isMod && e.shiftKey && e.key.toLowerCase() === 'z') {
                e.preventDefault(); redo();
            } else if (isMod && e.key.toLowerCase() === 'z') {
                e.preventDefault(); undo();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                if(selectedNodeId !== null) deleteNode(selectedNodeId);
            }
        };

        const handleNodeMouseDown = (e, nodeId) => {
            if (e.target.closest('.connector') || e.target.closest('.icon-btn')) return;
            setSelectedNode(nodeId);
            draggedNodeId = nodeId;
            const node = nodes.find(n => n.id === nodeId);
            
            if (e.altKey) {
                isDragCopying = true;
            } else {
                isDraggingNode = true;
                document.getElementById(`node-${nodeId}`).classList.add('dragging');
            }
            
            offset.x = e.clientX - node.x;
            offset.y = e.clientY - node.y;
        };

        const handleConnectorMouseDown = (e) => {
            if (!e.target.classList.contains('connector')) return;
            e.stopPropagation();
            isDrawingConnection = true;
            connectionStartNode = nodes.find(n => n.id === parseInt(e.target.closest('.node').id.split('-')[1]));
        };

        const handleMouseMove = (e) => {
            mouse.x = e.clientX - diagramContainer.getBoundingClientRect().left;
            mouse.y = e.clientY - diagramContainer.getBoundingClientRect().top;
            if (isDraggingNode && draggedNodeId !== null) {
                const node = nodes.find(n => n.id === draggedNodeId);
                if (node) {
                    node.x = mouse.x - offset.x;
                    node.y = mouse.y - offset.y;
                    const nodeEl = document.getElementById(`node-${draggedNodeId}`);
                    nodeEl.style.left = `${node.x}px`;
                    nodeEl.style.top = `${node.y}px`;
                    redrawAll();
                }
            } else if (isDrawingConnection) {
                redrawAll();
            }
        };

        const handleMouseUp = (e) => {
            if (isDragCopying) {
                const originalNode = nodes.find(n => n.id === draggedNodeId);
                const newNode = createNode(mouse.x - offset.x, mouse.y - offset.y, originalNode.name, originalNode.shape, originalNode.color);
                setSelectedNode(newNode.id);
            }
            
            if (isDrawingConnection) {
                const endTarget = document.elementFromPoint(e.clientX, e.clientY);
                const endNodeEl = endTarget.classList.contains('connector') ? endTarget.closest('.node') : null;
                if (endNodeEl && connectionStartNode) {
                    const endNodeId = parseInt(endNodeEl.id.split('-')[1]);
                    if (connectionStartNode.id !== endNodeId) {
                        connections.push({ from: connectionStartNode.id, to: endNodeId });
                        saveState();
                    }
                }
            }

            if (isDraggingNode && draggedNodeId !== null) {
                document.getElementById(`node-${draggedNodeId}`)?.classList.remove('dragging');
                saveState();
            }

            isDraggingNode = false; isDrawingConnection = false; isDragCopying = false;
            draggedNodeId = null; connectionStartNode = null;
            redrawAll();
        };

        const toggleSidebar = () => {
            isSidebarOpen = !isSidebarOpen;
            sidebar.classList.toggle('collapsed');
            mainContent.style.marginLeft = isSidebarOpen ? `${sidebar.offsetWidth}px` : '0px';
            setTimeout(resizeCanvas, 300);
        };

        // --- Initialization ---
        const init = () => {
            // Sidebar Drag & Drop
            document.querySelectorAll('.library-item').forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', JSON.stringify({ name: e.currentTarget.dataset.name, shape: e.currentTarget.dataset.shape }));
                });
            });
            diagramContainer.addEventListener('dragover', (e) => e.preventDefault());
            diagramContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                const rect = diagramContainer.getBoundingClientRect();
                createNode(e.clientX - rect.left - 80, e.clientY - rect.top - 48, data.name, data.shape);
            });
            
            // Listeners
            sidebarToggleBtn.addEventListener('click', toggleSidebar);
            resizeCanvas(); window.addEventListener('resize', resizeCanvas);
            addNodeBtn.addEventListener('click', () => createNode(canvas.width / 2 - 80, canvas.height / 2 - 48, 'New Page'));
            saveBtn.addEventListener('click', handleSave);
            document.addEventListener('mousedown', handleConnectorMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            diagramContainer.addEventListener('keydown', handleKeyDown);
            editTitleBtn.addEventListener('click', () => makeEditable(mainTitle));
            
            // Initial setup
            toggleSidebar(); // Start open
            createNode(150, 200, "Home Page", 'rectangle', VIBRANT_COLORS[0]);
            createNode(450, 350, "About Us", 'rectangle', VIBRANT_COLORS[1]);
            connections.push({from: 0, to: 1});
            saveState(); // Save initial state
            renderNodes();
        };

        init();
    });
    </script>
</body>
</html>
